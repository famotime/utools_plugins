<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å¼¥éš™ç¼©å›¾ - Seamless Crop</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f5f5f5;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .header {
      background: #fff;
      padding: 12px 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .header h1 {
      font-size: 18px;
      color: #333;
      font-weight: 600;
    }

    .status-info {
      font-size: 13px;
      color: #666;
    }

    .main-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      position: relative;
      overflow: auto;
      background: #e9ecef;
    }

    .canvas-help-overlay {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 14px;
      border-radius: 6px;
      font-size: 13px;
      color: #555;
      line-height: 1.8;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 10;
      pointer-events: none;
    }

    .canvas-info-overlay {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: rgba(255, 255, 255, 0.95);
      padding: 12px;
      border-radius: 6px;
      font-size: 13px;
      color: #666;
      line-height: 1.6;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 10;
      pointer-events: none;
      min-width: 200px;
    }

    .canvas-info-overlay strong {
      color: #333;
      display: block;
      margin-bottom: 6px;
    }

    .canvas-wrapper {
      position: relative;
      display: inline-block;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      background: #fff;
    }

    #canvas {
      display: block;
      cursor: crosshair;
    }

    .selection-overlay {
      position: absolute;
      border: 2px dashed #007bff;
      background: rgba(0, 123, 255, 0.1);
      pointer-events: none;
      display: none;
    }

    .selection-label {
      position: absolute;
      background: rgba(0, 123, 255, 0.9);
      color: white;
      padding: 4px 8px;
      font-size: 14px;
      border-radius: 3px;
      white-space: nowrap;
      pointer-events: none;
    }

    .control-panel {
      width: 250px;
      background: #fff;
      border-left: 1px solid #e0e0e0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      flex-shrink: 0;
      overflow-y: auto;
    }

    .control-section {
      margin-bottom: 12px;
    }

    .control-section h3 {
      font-size: 14px;
      color: #555;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .btn {
      width: 100%;
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin-bottom: 8px;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: #0056b3;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      background: #c82333;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #545b62;
    }

    .btn-success {
      background: #28a745;
      color: white;
    }

    .btn-success:hover:not(:disabled) {
      background: #218838;
    }

    .btn-light {
      background: #f8f9fa;
      color: #333;
      border: 1px solid #dee2e6;
    }

    .btn-light:hover:not(:disabled) {
      background: #e2e6ea;
    }

    .info-box {
      background: #f8f9fa;
      padding: 12px;
      border-radius: 6px;
      font-size: 13px;
      color: #666;
      line-height: 1.6;
    }

    .info-box strong {
      color: #333;
      display: block;
      margin-bottom: 4px;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
    }

    .help-text {
      font-size: 12px;
      color: #999;
      line-height: 1.5;
      margin-top: 4px;
      padding: 8px;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .placeholder {
      text-align: center;
      color: #999;
      font-size: 16px;
      padding: 40px;
    }

    .placeholder-icon {
      font-size: 48px;
      margin-bottom: 12px;
      opacity: 0.3;
    }

    .kbd {
      display: inline-block;
      padding: 2px 6px;
      background: #fff;
      color: #333;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-family: monospace;
      font-size: 11px;
      margin: 0 2px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>å¼¥éš™ç¼©å›¾ - Seamless Crop</h1>
    <div class="status-info" id="statusInfo">ç­‰å¾…å›¾ç‰‡...</div>
  </div>

  <div class="main-container">
    <div class="canvas-container" id="canvasContainer">
      <!-- Help overlay at top-left -->
      <div class="canvas-help-overlay">
        â€¢ æ»šè½®ç¼©æ”¾å›¾ç‰‡ï¼›â€¢ å³é”®æ‹–åŠ¨ç§»åŠ¨è§†å›¾ï¼›â€¢ å·¦é”®æ‹–åŠ¨é€‰æ‹©åŒºåŸŸï¼›
      </div>

      <!-- Info overlay at bottom-left -->
      <div class="canvas-info-overlay" id="imageInfo">
        <!-- <strong>å›¾ç‰‡ä¿¡æ¯</strong> -->
        <div class="info-item">
          <span><strong>å°ºå¯¸:</strong></span>
          <span id="imageDimensions">-</span>
        <!-- </div> -->
        <!-- <div class="info-item"> -->
          <span><strong>&nbsp;&nbsp;&nbsp;&nbsp;é€‰åŒºé«˜åº¦:</strong></span>
          <span id="selectionHeight">-</span>
        <!-- </div> -->
        <!-- <div class="info-item"> -->
          <span><strong>&nbsp;&nbsp;&nbsp;&nbsp;å¤„ç†åé«˜åº¦:</strong></span>
          <span id="resultHeight">-</span>
        <!-- </div> -->
        <!-- <div class="info-item"> -->
          <span><strong>&nbsp;&nbsp;&nbsp;&nbsp;ç¼©æ”¾:</strong></span>
          <span id="zoomLevel">100%</span>
        </div>
      </div>

      <div id="placeholder" class="placeholder">
        <div class="placeholder-icon">ğŸ–¼ï¸</div>
        <div>ä»å‰ªè´´æ¿ç²˜è´´å›¾ç‰‡æˆ–é‡æ–°å”¤èµ·æ’ä»¶</div>
      </div>
      <div class="canvas-wrapper" id="canvasWrapper" style="display: none;">
        <canvas id="canvas"></canvas>
        <div class="selection-overlay" id="selectionOverlay"></div>
        <div class="selection-label" id="selectionLabel" style="display: none;"></div>
      </div>
    </div>

    <div class="control-panel">
      <div class="control-section">
        <h3>ç¼–è¾‘æ“ä½œ</h3>
        <button id="stitchBtn" class="btn btn-danger" disabled>
          âœ‚ï¸ åˆ é™¤é€‰åŒº <span class="kbd">Delete</span>
        </button>
        <div class="help-text">
          åœ¨å›¾ç‰‡ä¸Šæ‹–æ‹½é€‰æ‹©è¦åˆ é™¤çš„åŒºåŸŸ
        </div>
      </div>

      <div class="control-section">
        <h3>å†å²è®°å½•</h3>
        <button id="undoBtn" class="btn btn-secondary" disabled>
          â†¶ æ’¤é”€ <span class="kbd">Ctrl+Z</span>
        </button>
        <button id="resetBtn" class="btn btn-light" disabled>
          ğŸ”„ é‡ç½®
        </button>
      </div>

      <div class="control-section">
        <h3>å¯¼å‡º</h3>
        <button id="saveBtn" class="btn btn-success" disabled>
          ğŸ’¾ ä¿å­˜å›¾ç‰‡ <span class="kbd">Ctrl+S</span>
        </button>
        <button id="copyBtn" class="btn btn-primary" disabled>
          ğŸ“‹ å¤åˆ¶åˆ°å‰ªè´´æ¿ <span class="kbd">Ctrl+C</span>
        </button>
      </div>

      <div class="control-section">
        <h3>åŠ è½½å›¾ç‰‡</h3>
        <button id="openBtn" class="btn btn-primary">
          ğŸ“ æ‰“å¼€æœ¬åœ°å›¾ç‰‡ <span class="kbd">Ctrl+O</span>
        </button>
        <button id="pasteBtn" class="btn btn-primary">
          ğŸ“‹ ä»å‰ªè´´æ¿ç²˜è´´ <span class="kbd">Ctrl+V</span>
        </button>
        <div class="help-text">
          å¯ä»¥æ‰“å¼€æœ¬åœ°æ–‡ä»¶æˆ–ä»å‰ªè´´æ¿ç²˜è´´æ–°å›¾ç‰‡
        </div>
      </div>

      <div class="control-section">
        <h3>è§†å›¾æ§åˆ¶</h3>
        <button id="resetViewBtn" class="btn btn-light">
          ğŸ” é‡ç½®è§†å›¾ <span class="kbd">R</span>
        </button>
      </div>

      <div class="help-text">
        <strong style="font-size: 13px; color: #333;">å¿«æ·é”®:</strong><br>
        <span class="kbd">Ctrl+O</span> æ‰“å¼€å›¾ç‰‡<br>
        <span class="kbd">Ctrl+V</span> ç²˜è´´å›¾ç‰‡<br>
        <span class="kbd">Ctrl+Z</span> æ’¤é”€<br>
        <span class="kbd">Ctrl+S</span> ä¿å­˜<br>
        <span class="kbd">Ctrl+C</span> å¤åˆ¶<br>
        <span class="kbd">R</span> é‡ç½®è§†å›¾<br>
        <span class="kbd">Delete</span> åˆ é™¤é€‰åŒº<br>
        <span class="kbd">Esc</span> æ¸…é™¤é€‰åŒº
      </div>
    </div>
  </div>

  <script>
    // ==================== Global State ====================
    let canvas = null;
    let ctx = null;
    let originalImage = null;
    let currentImageData = null;
    let history = []; // Undo history stack
    const MAX_HISTORY = 10;

    // Selection state
    let isSelecting = false;
    let selectionStart = { x: 0, y: 0 };
    let selectionEnd = { x: 0, y: 0 };
    let hasSelection = false;

    // Zoom and pan state
    let scale = 1.0;
    let offsetX = 0;
    let offsetY = 0;
    const MIN_SCALE = 0.1;
    const MAX_SCALE = 10;
    const SCALE_STEP = 0.1;

    // Pan state (right mouse button)
    let isPanning = false;
    let panStart = { x: 0, y: 0 };

    // ==================== Initialization ====================
    window.onload = () => {
      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');
      initializeEventListeners();

      // Listen for plugin entry
      if (typeof utools !== 'undefined') {
        utools.onPluginEnter(({ type, payload }) => {
          if (type === 'img' && payload) {
            loadImageFromDataURL(payload);
          }
        });
      }
    };

    // ==================== Event Listeners ====================
    function initializeEventListeners() {
      // Canvas mouse events
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('mouseleave', handleMouseLeave);
      canvas.addEventListener('wheel', handleWheel, { passive: false });
      canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent context menu

      // Button events
      document.getElementById('stitchBtn').addEventListener('click', removeAndStitch);
      document.getElementById('undoBtn').addEventListener('click', undo);
      document.getElementById('saveBtn').addEventListener('click', saveImage);
      document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
      document.getElementById('resetBtn').addEventListener('click', resetImage);
      document.getElementById('openBtn').addEventListener('click', handleOpenImage);
      document.getElementById('pasteBtn').addEventListener('click', handlePasteImage);
      document.getElementById('resetViewBtn').addEventListener('click', resetView);

      // Keyboard shortcuts
      document.addEventListener('keydown', handleKeyboard);
    }

    // ==================== Image Loading ====================
    function loadImageFromDataURL(dataURL, options = {}) {
      const { clearHistoryOnLoad = true, resetViewOnLoad = true } = options;

      const img = new Image();
      img.onload = () => {
        originalImage = img;
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        // Show canvas, hide placeholder
        document.getElementById('placeholder').style.display = 'none';
        document.getElementById('canvasWrapper').style.display = 'inline-block';

        // Reset view (zoom and pan) - optional for undo
        if (resetViewOnLoad) {
          resetView();
        }

        // Update UI
        updateImageInfo();
        enableButtons();
        clearSelection();

        // Only clear history for new images, not when undoing
        if (clearHistoryOnLoad) {
          clearHistory();
          // Save initial state only for new images
          saveToHistory();
        }

        updateStatus('å›¾ç‰‡å·²åŠ è½½');
      };
      img.onerror = () => {
        updateStatus('å›¾ç‰‡åŠ è½½å¤±è´¥');
        if (typeof utools !== 'undefined') {
          utools.showNotification('å›¾ç‰‡åŠ è½½å¤±è´¥');
        }
      };
      img.src = dataURL;
    }

    // ==================== Mouse Selection and Pan ====================
    function handleMouseDown(e) {
      if (!canvas.width) return;

      // Right button (button === 2): Pan
      if (e.button === 2) {
        isPanning = true;
        panStart = {
          x: e.clientX - offsetX,
          y: e.clientY - offsetY
        };
        canvas.style.cursor = 'grabbing';
        return;
      }

      // Left button (button === 0): Select
      if (e.button === 0) {
        const rect = canvas.getBoundingClientRect();

        // Convert screen coordinates to canvas coordinates
        // Since we removed CSS max-width/height, only transform scale affects the size
        const canvasX = (e.clientX - rect.left) / scale;
        const canvasY = (e.clientY - rect.top) / scale;

        selectionStart = {
          x: canvasX,
          y: canvasY
        };

        isSelecting = true;
        hasSelection = false;
        hideSelectionOverlay();
      }
    }

    function handleMouseMove(e) {
      // Handle panning with right mouse button
      if (isPanning) {
        offsetX = e.clientX - panStart.x;
        offsetY = e.clientY - panStart.y;
        applyTransform();
        return;
      }

      // Handle selection with left mouse button
      if (isSelecting) {
        const rect = canvas.getBoundingClientRect();

        // Convert screen coordinates to canvas coordinates
        const canvasX = (e.clientX - rect.left) / scale;
        const canvasY = (e.clientY - rect.top) / scale;

        selectionEnd = {
          x: canvasX,
          y: canvasY
        };

        showSelectionOverlay();
      }
    }

    function handleMouseUp(e) {
      // Handle pan end
      if (isPanning && e.button === 2) {
        isPanning = false;
        canvas.style.cursor = 'crosshair';
        return;
      }

      // Handle selection end
      if (isSelecting && e.button === 0) {
        isSelecting = false;

        const rect = canvas.getBoundingClientRect();

        // Convert screen coordinates to canvas coordinates
        const canvasX = (e.clientX - rect.left) / scale;
        const canvasY = (e.clientY - rect.top) / scale;

        selectionEnd = {
          x: canvasX,
          y: canvasY
        };

        // Validate selection
        const minHeight = 5;
        const height = Math.abs(selectionEnd.y - selectionStart.y);

        if (height >= minHeight) {
          hasSelection = true;
          showSelectionOverlay();
          document.getElementById('stitchBtn').disabled = false;
          updateImageInfo();
        } else {
          clearSelection();
        }
      }
    }

    function handleMouseLeave(e) {
      if (isSelecting) {
        handleMouseUp(e);
      }
      if (isPanning) {
        isPanning = false;
        canvas.style.cursor = 'crosshair';
      }
    }

    // ==================== Zoom Control ====================
    function handleWheel(e) {
      e.preventDefault();

      if (!canvas.width) return;

      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Calculate zoom direction
      const delta = e.deltaY > 0 ? -SCALE_STEP : SCALE_STEP;
      const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale + delta));

      if (newScale !== scale) {
        // Zoom towards mouse position
        const scaleFactor = newScale / scale;

        offsetX = mouseX - (mouseX - offsetX) * scaleFactor;
        offsetY = mouseY - (mouseY - offsetY) * scaleFactor;

        scale = newScale;

        applyTransform();
        updateZoomDisplay();
      }
    }

    function resetView() {
      // Calculate optimal initial scale to fit the canvas in viewport
      const container = document.getElementById('canvasContainer');
      const containerRect = container.getBoundingClientRect();

      // Available space (with some padding)
      const maxWidth = containerRect.width - 40;
      const maxHeight = containerRect.height - 40;

      // Calculate scale to fit
      const scaleToFitWidth = maxWidth / canvas.width;
      const scaleToFitHeight = maxHeight / canvas.height;
      const scaleToFit = Math.min(scaleToFitWidth, scaleToFitHeight, 1.0); // Don't scale up

      scale = scaleToFit;

      // Center the image
      offsetX = (containerRect.width - canvas.width * scale) / 2;
      offsetY = (containerRect.height - canvas.height * scale) / 2;

      applyTransform();
      updateZoomDisplay();
    }

    function applyTransform() {
      if (!canvas.width) return;

      // Apply transform to wrapper (this will affect both canvas and overlay)
      const wrapper = document.getElementById('canvasWrapper');
      wrapper.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
      wrapper.style.transformOrigin = '0 0';
    }

    function updateZoomDisplay() {
      const zoomPercent = Math.round(scale * 100);
      document.getElementById('zoomLevel').textContent = `${zoomPercent}%`;
    }

    // ==================== Selection Overlay ====================
    function showSelectionOverlay() {
      const overlay = document.getElementById('selectionOverlay');
      const label = document.getElementById('selectionLabel');

      const top = Math.min(selectionStart.y, selectionEnd.y);
      const height = Math.abs(selectionEnd.y - selectionStart.y);

      // Since overlay is a child of canvasWrapper which already has transform applied,
      // we should use canvas coordinates directly, not screen coordinates
      overlay.style.display = 'block';
      overlay.style.left = '0px';
      overlay.style.top = top + 'px';
      overlay.style.width = canvas.width + 'px';
      overlay.style.height = height + 'px';

      // Show label
      label.style.display = 'block';
      label.style.left = '10px';
      label.style.top = (top + 10) + 'px';
      label.textContent = `åˆ é™¤åŒºåŸŸé«˜åº¦: ${Math.round(height)}px`;
    }

    function hideSelectionOverlay() {
      document.getElementById('selectionOverlay').style.display = 'none';
      document.getElementById('selectionLabel').style.display = 'none';
    }

    function clearSelection() {
      hasSelection = false;
      isSelecting = false;
      hideSelectionOverlay();
      document.getElementById('stitchBtn').disabled = true;
      updateImageInfo();
    }

    // ==================== Image Processing ====================
    function removeAndStitch() {
      if (!hasSelection || !canvas.width) return;

      // Save current state to history
      saveToHistory();

      const topY = Math.min(selectionStart.y, selectionEnd.y);
      const bottomY = Math.max(selectionStart.y, selectionEnd.y);
      const gapHeight = bottomY - topY;
      const imageWidth = canvas.width;
      const imageHeight = canvas.height;

      // Calculate new dimensions
      const newHeight = imageHeight - gapHeight;
      const topSectionHeight = topY;
      const bottomSectionHeight = imageHeight - bottomY;

      // Create temporary canvas
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = imageWidth;
      tempCanvas.height = newHeight;

      // Draw top section
      if (topSectionHeight > 0) {
        tempCtx.drawImage(
          canvas,
          0, 0, imageWidth, topY,  // Source
          0, 0, imageWidth, topY   // Destination
        );
      }

      // Draw bottom section
      if (bottomSectionHeight > 0) {
        tempCtx.drawImage(
          canvas,
          0, bottomY, imageWidth, bottomSectionHeight,  // Source
          0, topY, imageWidth, bottomSectionHeight       // Destination
        );
      }

      // Update main canvas
      canvas.width = imageWidth;
      canvas.height = newHeight;
      ctx.drawImage(tempCanvas, 0, 0);

      // Clear selection
      clearSelection();

      // Update UI
      updateImageInfo();
      updateStatus('å›¾ç‰‡å·²å¤„ç†');

      if (typeof utools !== 'undefined') {
        utools.showNotification(`å·²åˆ é™¤ ${Math.round(gapHeight)}px é«˜åº¦çš„åŒºåŸŸ`);
      }
    }

    // ==================== History / Undo ====================
    function saveToHistory() {
      const dataURL = canvas.toDataURL('image/png');
      history.push(dataURL);

      // Limit history size
      if (history.length > MAX_HISTORY) {
        history.shift();
      }

      updateUndoButton();
    }

    function undo() {
      if (history.length <= 1) return; // Keep at least one state

      history.pop(); // Remove current state
      const previousState = history[history.length - 1];

      if (previousState) {
        // Don't clear history or reset view when undoing
        loadImageFromDataURL(previousState, {
          clearHistoryOnLoad: false,
          resetViewOnLoad: false
        });
        updateStatus('å·²æ’¤é”€');
      }

      updateUndoButton();
    }

    function clearHistory() {
      history = [];
      updateUndoButton();
    }

    function updateUndoButton() {
      document.getElementById('undoBtn').disabled = history.length <= 1;
    }

    // ==================== Export Functions ====================
    function saveImage() {
      if (!canvas.width) {
        if (typeof utools !== 'undefined') {
          utools.showNotification('æ²¡æœ‰å¯ä¿å­˜çš„å›¾ç‰‡');
        }
        return;
      }

      // Show loading notification
      updateStatus('æ­£åœ¨å‡†å¤‡ä¿å­˜...');

      // Disable button and show loading state
      const saveBtn = document.getElementById('saveBtn');
      const originalText = saveBtn.innerHTML;
      saveBtn.disabled = true;
      saveBtn.innerHTML = 'â³ å‡†å¤‡ä¸­...';

      const dataURL = canvas.toDataURL('image/png');

      if (typeof window.saveImageToFile === 'function') {
        console.log('Calling saveImageToFile from preload');
        const result = window.saveImageToFile(dataURL);
        console.log('Save result:', result);

        if (result && result.success) {
          updateStatus(`å·²ä¿å­˜: ${result.filename}`);
          // Show success state
          saveBtn.innerHTML = 'âœ… ä¿å­˜æˆåŠŸï¼';
          saveBtn.classList.remove('btn-success');
          saveBtn.classList.add('btn-success');

          // Reset button after 2 seconds
          setTimeout(() => {
            saveBtn.innerHTML = originalText;
            saveBtn.disabled = false;
          }, 2000);
        } else if (result && result.cancelled) {
          updateStatus('å·²å–æ¶ˆä¿å­˜');
          // Reset button immediately
          saveBtn.innerHTML = originalText;
          saveBtn.disabled = false;
        } else {
          updateStatus('ä¿å­˜å¤±è´¥');
          // Show error state
          saveBtn.innerHTML = 'âŒ ä¿å­˜å¤±è´¥';
          saveBtn.classList.remove('btn-success');
          saveBtn.classList.add('btn-danger');

          // Reset button after 2 seconds
          setTimeout(() => {
            saveBtn.innerHTML = originalText;
            saveBtn.classList.remove('btn-danger');
            saveBtn.classList.add('btn-success');
            saveBtn.disabled = false;
          }, 2000);
        }
      } else {
        console.error('saveImageToFile function not available');
        if (typeof utools !== 'undefined') {
          utools.showNotification('ä¿å­˜åŠŸèƒ½ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ preload.js');
        }
        updateStatus('ä¿å­˜åŠŸèƒ½ä¸å¯ç”¨');
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = false;
      }
    }

    function copyToClipboard() {
      if (!canvas.width) {
        if (typeof utools !== 'undefined') {
          utools.showNotification('æ²¡æœ‰å¯å¤åˆ¶çš„å›¾ç‰‡');
        }
        return;
      }

      updateStatus('æ­£åœ¨å¤åˆ¶åˆ°å‰ªè´´æ¿...');

      // Disable button and show loading state
      const copyBtn = document.getElementById('copyBtn');
      const originalText = copyBtn.innerHTML;
      copyBtn.disabled = true;
      copyBtn.innerHTML = 'â³ å¤åˆ¶ä¸­...';

      const dataURL = canvas.toDataURL('image/png');
      if (typeof window.copyImageToClipboard === 'function') {
        const success = window.copyImageToClipboard(dataURL);

        if (success) {
          updateStatus('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
          // Show success state
          copyBtn.innerHTML = 'âœ… å¤åˆ¶æˆåŠŸï¼';
          copyBtn.classList.remove('btn-primary');
          copyBtn.classList.add('btn-success');

          // Reset button after 2 seconds
          setTimeout(() => {
            copyBtn.innerHTML = originalText;
            copyBtn.classList.remove('btn-success');
            copyBtn.classList.add('btn-primary');
            copyBtn.disabled = false;
          }, 2000);
        } else {
          updateStatus('å¤åˆ¶å¤±è´¥');
          // Show error state
          copyBtn.innerHTML = 'âŒ å¤åˆ¶å¤±è´¥';
          copyBtn.classList.remove('btn-primary');
          copyBtn.classList.add('btn-danger');

          // Reset button after 2 seconds
          setTimeout(() => {
            copyBtn.innerHTML = originalText;
            copyBtn.classList.remove('btn-danger');
            copyBtn.classList.add('btn-primary');
            copyBtn.disabled = false;
          }, 2000);
        }
      } else {
        console.error('Copy function not available');
        if (typeof utools !== 'undefined') {
          utools.showNotification('å¤åˆ¶åŠŸèƒ½ä¸å¯ç”¨');
        }
        updateStatus('å¤åˆ¶åŠŸèƒ½ä¸å¯ç”¨');
        copyBtn.innerHTML = originalText;
        copyBtn.disabled = false;
      }
    }

    function resetImage() {
      if (!originalImage) return;

      if (history.length > 0) {
        const originalState = history[0];
        // Reset to original but don't clear history or reset view
        loadImageFromDataURL(originalState, {
          clearHistoryOnLoad: false,
          resetViewOnLoad: false
        });
        updateStatus('å·²é‡ç½®åˆ°åŸå§‹å›¾ç‰‡');
      }
    }

    // ==================== Load Image Functions ====================
    function handleOpenImage() {
      console.log('Opening image file...');
      updateStatus('æ­£åœ¨æ‰“å¼€æ–‡ä»¶...');

      if (typeof window.openImageFile === 'function') {
        const dataURL = window.openImageFile();

        if (dataURL) {
          loadImageFromDataURL(dataURL);
          updateStatus('å›¾ç‰‡å·²åŠ è½½');
        } else {
          updateStatus('æœªé€‰æ‹©å›¾ç‰‡');
        }
      } else {
        console.error('openImageFile function not available in preload');
        if (typeof utools !== 'undefined') {
          utools.showNotification('æ‰“å¼€æ–‡ä»¶åŠŸèƒ½ä¸å¯ç”¨');
        }
        updateStatus('æ‰“å¼€æ–‡ä»¶åŠŸèƒ½ä¸å¯ç”¨');
      }
    }

    function handlePasteImage() {
      console.log('Pasting from clipboard...');
      updateStatus('æ­£åœ¨ä»å‰ªè´´æ¿ç²˜è´´...');

      if (typeof window.getClipboardImage === 'function') {
        const dataURL = window.getClipboardImage();

        if (dataURL) {
          loadImageFromDataURL(dataURL);
          updateStatus('å›¾ç‰‡å·²ç²˜è´´');
          if (typeof utools !== 'undefined') {
            utools.showNotification('âœ… å·²ä»å‰ªè´´æ¿ç²˜è´´å›¾ç‰‡');
          }
        } else {
          updateStatus('å‰ªè´´æ¿ä¸­æ²¡æœ‰å›¾ç‰‡');
          if (typeof utools !== 'undefined') {
            utools.showNotification('å‰ªè´´æ¿ä¸­æ²¡æœ‰å›¾ç‰‡');
          }
        }
      } else {
        console.error('getClipboardImage function not available in preload');
        if (typeof utools !== 'undefined') {
          utools.showNotification('ç²˜è´´åŠŸèƒ½ä¸å¯ç”¨');
        }
        updateStatus('ç²˜è´´åŠŸèƒ½ä¸å¯ç”¨');
      }
    }

    // ==================== UI Updates ====================
    function updateImageInfo() {
      const dimensions = canvas.width ? `${canvas.width} Ã— ${canvas.height}` : '-';
      document.getElementById('imageDimensions').textContent = dimensions;

      if (hasSelection) {
        const height = Math.abs(selectionEnd.y - selectionStart.y);
        const resultHeight = canvas.height - height;
        document.getElementById('selectionHeight').textContent = Math.round(height) + 'px';
        document.getElementById('resultHeight').textContent = Math.round(resultHeight) + 'px';
      } else {
        document.getElementById('selectionHeight').textContent = '-';
        document.getElementById('resultHeight').textContent = canvas.height ? canvas.height + 'px' : '-';
      }
    }

    function updateStatus(text) {
      document.getElementById('statusInfo').textContent = text;
    }

    function enableButtons() {
      document.getElementById('saveBtn').disabled = false;
      document.getElementById('copyBtn').disabled = false;
      document.getElementById('resetBtn').disabled = false;
    }

    // ==================== Keyboard Shortcuts ====================
    function handleKeyboard(e) {
      // Ctrl+O: Open image file
      if (e.ctrlKey && e.key === 'o') {
        e.preventDefault();
        handleOpenImage();
      }

      // Ctrl+V: Paste from clipboard
      if (e.ctrlKey && e.key === 'v') {
        e.preventDefault();
        handlePasteImage();
      }

      // Ctrl+Z: Undo
      if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        undo();
      }

      // Ctrl+S: Save
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        saveImage();
      }

      // Ctrl+C: Copy
      if (e.ctrlKey && e.key === 'c') {
        e.preventDefault();
        copyToClipboard();
      }

      // R: Reset view
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        resetView();
      }

      // Delete: Remove selection
      if (e.key === 'Delete' && hasSelection) {
        e.preventDefault();
        removeAndStitch();
      }

      // Escape: Clear selection
      if (e.key === 'Escape') {
        e.preventDefault();
        clearSelection();
      }
    }
  </script>
</body>
</html>
